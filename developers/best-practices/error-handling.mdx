---
title: "Error Handling Best Practices"
description: "Consistent error handling patterns for robust application behavior"
---

## Overview

Proper error handling is essential for:
- **User experience** - Clear, actionable error messages
- **Debugging** - Detailed logs for troubleshooting
- **Security** - Not exposing sensitive information
- **Reliability** - Graceful degradation and recovery

Juryo follows consistent error handling patterns across the entire application to ensure reliability and maintainability.

## Standard Error Response Format

All API endpoints use a consistent error response structure:

<Snippet file="error-response-format.mdx" />

### Success Responses

```typescript
{
  "success": true,
  "data": {
    // Response payload
  }
}
```

### Error Responses

```typescript
{
  "success": false,
  "error": "User-friendly error message",
  "details": "Optional technical details for debugging"
}
```

## HTTP Status Codes

Use appropriate HTTP status codes to indicate error types:

### Client Errors (4xx)

| Code | Meaning | Use Case | Example |
|------|---------|----------|---------|
| `400` | Bad Request | Invalid input, validation errors | Missing required fields |
| `401` | Unauthorized | Not authenticated | No session cookie |
| `403` | Forbidden | Authenticated but no permission | Wrong tenant access |
| `404` | Not Found | Resource doesn't exist | Contact ID not found |
| `409` | Conflict | Resource conflict | Duplicate email address |
| `422` | Unprocessable Entity | Semantic validation errors | Invalid date range |
| `429` | Too Many Requests | Rate limit exceeded | Too many API calls |

### Server Errors (5xx)

| Code | Meaning | Use Case | Example |
|------|---------|----------|---------|
| `500` | Internal Server Error | Unexpected server errors | Database connection failed |
| `502` | Bad Gateway | Upstream service failure | Gemini API timeout |
| `503` | Service Unavailable | Temporary unavailability | Database maintenance |
| `504` | Gateway Timeout | Upstream timeout | External API too slow |

## Try-Catch Patterns

### Basic Pattern

Every route handler should wrap operations in try-catch:

```typescript
// ✅ CORRECT - Try-catch with appropriate error response
app.get('/api/contacts/:id', async (req, res) => {
  try {
    const { id } = req.params;

    // Validate input
    if (!id) {
      return res.status(400).json({
        success: false,
        error: 'Contact ID is required'
      });
    }

    // Database operation
    const [contact] = await db.select()
      .from(contacts)
      .where(and(
        eq(contacts.tenantId, req.tenantId),
        eq(contacts.id, id)
      ))
      .limit(1);

    // Handle not found
    if (!contact) {
      return res.status(404).json({
        success: false,
        error: 'Contact not found'
      });
    }

    // Success
    res.json({
      success: true,
      data: contact
    });

  } catch (error) {
    console.error('Error fetching contact:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch contact',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// ❌ WRONG - No error handling
app.get('/api/contacts/:id', async (req, res) => {
  const [contact] = await db.select()
    .from(contacts)
    .where(eq(contacts.id, req.params.id));  // Will crash on database error

  res.json({ success: true, data: contact });
});
```

### Nested Operations

For multiple operations, use try-catch strategically:

```typescript
app.post('/api/opportunities', async (req, res) => {
  try {
    const { contactId, title, stage, estimatedValue } = req.body;

    // Validate required fields
    if (!contactId || !title) {
      return res.status(400).json({
        success: false,
        error: 'Contact ID and title are required'
      });
    }

    // Check contact exists in same tenant
    try {
      const [contact] = await db.select()
        .from(contacts)
        .where(and(
          eq(contacts.tenantId, req.tenantId),
          eq(contacts.id, contactId)
        ))
        .limit(1);

      if (!contact) {
        return res.status(404).json({
          success: false,
          error: 'Contact not found'
        });
      }
    } catch (error) {
      console.error('Error validating contact:', error);
      return res.status(500).json({
        success: false,
        error: 'Failed to validate contact'
      });
    }

    // Create opportunity
    const [opportunity] = await db.insert(opportunities).values({
      id: crypto.randomUUID(),
      tenantId: req.tenantId,
      contactId,
      title,
      stage: stage || 'lead',
      estimatedValue: estimatedValue || 0,
    }).returning();

    res.json({
      success: true,
      data: opportunity
    });

  } catch (error) {
    console.error('Error creating opportunity:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to create opportunity',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});
```

## Database Error Handling

### Foreign Key Violations

```typescript
try {
  await db.insert(opportunities).values({
    tenantId: req.tenantId,
    contactId: 'invalid-id',  // Foreign key violation
    title: 'Test',
  });
} catch (error: any) {
  if (error.code === '23503') {  // PostgreSQL foreign key violation
    return res.status(400).json({
      success: false,
      error: 'Invalid contact ID'
    });
  }
  throw error;  // Re-throw other errors
}
```

### Unique Constraint Violations

```typescript
try {
  await db.insert(contacts).values({
    tenantId: req.tenantId,
    email: 'existing@example.com',  // Duplicate email
  });
} catch (error: any) {
  if (error.code === '23505') {  // PostgreSQL unique violation
    return res.status(409).json({
      success: false,
      error: 'Contact with this email already exists'
    });
  }
  throw error;
}
```

### Connection Errors

```typescript
try {
  const results = await db.select().from(contacts);
} catch (error: any) {
  if (error.code === 'ECONNREFUSED') {
    console.error('Database connection refused');
    return res.status(503).json({
      success: false,
      error: 'Database temporarily unavailable'
    });
  }

  if (error.message?.includes('timeout')) {
    return res.status(504).json({
      success: false,
      error: 'Database query timeout'
    });
  }

  throw error;
}
```

## Validation Errors

### Input Validation

Use clear, actionable validation messages:

```typescript
// ✅ GOOD - Specific validation errors
function validateContact(data: any): string[] {
  const errors: string[] = [];

  if (!data.firstName || data.firstName.trim() === '') {
    errors.push('First name is required');
  }

  if (!data.email || !data.email.includes('@')) {
    errors.push('Valid email address is required');
  }

  if (data.phone && !/^\+?[1-9]\d{1,14}$/.test(data.phone)) {
    errors.push('Phone number must be in E.164 format (+1234567890)');
  }

  return errors;
}

app.post('/api/contacts', async (req, res) => {
  try {
    const validationErrors = validateContact(req.body);

    if (validationErrors.length > 0) {
      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: validationErrors.join(', ')
      });
    }

    // Proceed with creation...
  } catch (error) {
    // Handle unexpected errors
  }
});

// ❌ BAD - Vague validation errors
if (!data.email) {
  throw new Error('Invalid data');  // Not helpful!
}
```

### Type Validation

```typescript
function validateOpportunityStage(stage: string): boolean {
  const validStages = [
    'lead',
    'contacted',
    'qualified',
    'appointment_booked',
    'proposal_sent',
    'won',
    'lost'
  ];

  return validStages.includes(stage);
}

app.patch('/api/opportunities/:id', async (req, res) => {
  try {
    const { stage } = req.body;

    if (stage && !validateOpportunityStage(stage)) {
      return res.status(400).json({
        success: false,
        error: `Invalid stage. Must be one of: ${validStages.join(', ')}`
      });
    }

    // Update opportunity...
  } catch (error) {
    // Handle unexpected errors
  }
});
```

## Async Error Handling

### Promise Chains

```typescript
// ✅ GOOD - Catch errors in promise chain
app.get('/api/analytics/opportunity', async (req, res) => {
  db.select()
    .from(opportunities)
    .where(eq(opportunities.tenantId, req.tenantId))
    .then((data) => {
      res.json({ success: true, data });
    })
    .catch((error) => {
      console.error('Error fetching opportunities:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch opportunities'
      });
    });
});

// ❌ BAD - Unhandled promise rejection
app.get('/api/analytics/opportunity', (req, res) => {
  db.select()
    .from(opportunities)
    .then((data) => {
      res.json({ success: true, data });
    });
  // No .catch() - will cause unhandled rejection!
});
```

### Parallel Operations

```typescript
app.get('/api/dashboard', async (req, res) => {
  try {
    // Execute multiple queries in parallel
    const [contactsResult, opportunitiesResult, casesResult] = await Promise.allSettled([
      db.select().from(contacts).where(eq(contacts.tenantId, req.tenantId)),
      db.select().from(opportunities).where(eq(opportunities.tenantId, req.tenantId)),
      db.select().from(cases).where(eq(cases.tenantId, req.tenantId)),
    ]);

    // Check for failures
    const contacts = contactsResult.status === 'fulfilled' ? contactsResult.value : [];
    const opportunities = opportunitiesResult.status === 'fulfilled' ? opportunitiesResult.value : [];
    const cases = casesResult.status === 'fulfilled' ? casesResult.value : [];

    // Log failures but don't fail entire request
    if (contactsResult.status === 'rejected') {
      console.error('Failed to fetch contacts:', contactsResult.reason);
    }

    res.json({
      success: true,
      data: {
        contacts,
        opportunities,
        cases
      }
    });

  } catch (error) {
    console.error('Dashboard error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to load dashboard'
    });
  }
});
```

## Error Logging

### Development vs. Production

```typescript
function logError(error: Error, context: string) {
  if (process.env.NODE_ENV === 'development') {
    // Detailed logging in development
    console.error(`[${context}] Error:`, {
      message: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString()
    });
  } else {
    // Structured logging in production
    console.error(JSON.stringify({
      level: 'error',
      context,
      message: error.message,
      timestamp: new Date().toISOString(),
      // Don't log stack traces in production (sensitive info)
    }));
  }
}

// Usage in route handlers
app.get('/api/contacts', async (req, res) => {
  try {
    // ... operations
  } catch (error) {
    logError(error as Error, 'fetch-contacts');
    res.status(500).json({
      success: false,
      error: 'Failed to fetch contacts'
    });
  }
});
```

### Error Context

Include context in error logs:

```typescript
try {
  await db.insert(contacts).values(contactData);
} catch (error) {
  console.error('Failed to create contact:', {
    error: error.message,
    tenantId: req.tenantId,
    userId: req.user?.id,
    contactData: {
      // Log non-sensitive fields only
      firstName: contactData.firstName,
      // Don't log PII like email, phone
    }
  });
  throw error;
}
```

## External API Error Handling

### WhatsApp API

```typescript
async function sendWhatsAppMessage(phone: string, message: string) {
  try {
    const response = await fetch(
      `${process.env.WHATSAPP_API_URL}/${process.env.WHATSAPP_PHONE_NUMBER_ID}/messages`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.WHATSAPP_API_KEY}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messaging_product: 'whatsapp',
          to: phone,
          text: { body: message },
        }),
      }
    );

    if (!response.ok) {
      const errorData = await response.json();

      // Handle specific WhatsApp errors
      if (response.status === 401) {
        throw new Error('WhatsApp API authentication failed');
      }

      if (response.status === 400 && errorData.error?.code === 131051) {
        throw new Error('Recipient opted out of WhatsApp messages');
      }

      if (response.status === 400 && errorData.error?.message?.includes('24 hours')) {
        throw new Error('Outside 24-hour messaging window. Use message template.');
      }

      throw new Error(`WhatsApp API error: ${errorData.error?.message || 'Unknown error'}`);
    }

    return await response.json();

  } catch (error) {
    console.error('WhatsApp send error:', error);
    throw error;
  }
}

// Usage in route handler
app.post('/api/whatsapp/send', async (req, res) => {
  try {
    const { phone, message } = req.body;

    await sendWhatsAppMessage(phone, message);

    res.json({
      success: true,
      data: { message: 'Message sent' }
    });

  } catch (error: any) {
    console.error('Failed to send WhatsApp message:', error);

    // Return user-friendly error
    res.status(500).json({
      success: false,
      error: error.message || 'Failed to send message'
    });
  }
});
```

### Google Gemini API

```typescript
async function analyzeDocument(documentContent: string) {
  try {
    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1/models/gemini-pro:generateContent?key=${process.env.GEMINI_API_KEY}`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{
            parts: [{ text: `Analyze this legal document: ${documentContent}` }]
          }]
        }),
        signal: AbortSignal.timeout(30000),  // 30 second timeout
      }
    );

    if (!response.ok) {
      if (response.status === 429) {
        throw new Error('Gemini API rate limit exceeded. Try again later.');
      }

      if (response.status === 400) {
        const errorData = await response.json();
        throw new Error(`Invalid request: ${errorData.error?.message}`);
      }

      throw new Error('Gemini API request failed');
    }

    return await response.json();

  } catch (error: any) {
    if (error.name === 'AbortError') {
      throw new Error('Document analysis timed out');
    }
    throw error;
  }
}
```

## User-Facing Error Messages

### Be Specific and Actionable

```typescript
// ✅ GOOD - Clear, actionable error messages
"Contact with email john@example.com already exists"
"Phone number must include country code (e.g., +1234567890)"
"Opportunity stage must be one of: lead, contacted, qualified, appointment_booked, proposal_sent, won, lost"
"Cannot delete contact with active cases"

// ❌ BAD - Vague, unhelpful errors
"Invalid data"
"Operation failed"
"Error 500"
"Something went wrong"
```

### Security Considerations

Don't expose sensitive information in errors:

```typescript
// ✅ GOOD - Vague for security
try {
  const user = await authenticateUser(email, password);
} catch (error) {
  // Don't reveal whether email exists
  return res.status(401).json({
    success: false,
    error: 'Invalid email or password'
  });
}

// ❌ BAD - Reveals user existence
try {
  const user = await findUserByEmail(email);
  if (!user) {
    return res.status(404).json({
      success: false,
      error: 'No user with that email'  // Exposes user existence!
    });
  }
  // ...
}
```

## Error Recovery Strategies

### Retry Logic

```typescript
async function retryOperation<T>(
  operation: () => Promise<T>,
  maxRetries: number = 3,
  delay: number = 1000
): Promise<T> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      console.error(`Attempt ${attempt} failed:`, error);

      if (attempt === maxRetries) {
        throw error;  // Final attempt failed
      }

      // Exponential backoff
      await new Promise(resolve => setTimeout(resolve, delay * attempt));
    }
  }

  throw new Error('Operation failed after retries');
}

// Usage
try {
  const result = await retryOperation(() =>
    sendWhatsAppMessage(phone, message)
  );
} catch (error) {
  console.error('Failed after 3 retries:', error);
  // Handle permanent failure
}
```

### Graceful Degradation

```typescript
app.get('/api/contacts/:id', async (req, res) => {
  try {
    const [contact] = await db.select()
      .from(contacts)
      .where(and(
        eq(contacts.tenantId, req.tenantId),
        eq(contacts.id, req.params.id)
      ));

    if (!contact) {
      return res.status(404).json({
        success: false,
        error: 'Contact not found'
      });
    }

    // Try to fetch opportunities (optional data)
    let opportunities = [];
    try {
      opportunities = await db.select()
        .from(opportunities)
        .where(and(
          eq(opportunities.tenantId, req.tenantId),
          eq(opportunities.contactId, contact.id)
        ));
    } catch (error) {
      console.error('Failed to fetch opportunities:', error);
      // Continue without opportunities data
    }

    res.json({
      success: true,
      data: {
        contact,
        opportunities,  // Empty array if fetch failed
      }
    });

  } catch (error) {
    console.error('Error fetching contact:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch contact'
    });
  }
});
```

### Circuit Breaker Pattern

For external APIs that may be unreliable:

```typescript
class CircuitBreaker {
  private failureCount = 0;
  private lastFailureTime: number | null = null;
  private readonly threshold = 5;
  private readonly timeout = 60000;  // 1 minute

  async execute<T>(operation: () => Promise<T>): Promise<T> {
    // Check if circuit is open
    if (this.isOpen()) {
      throw new Error('Circuit breaker is open. Service temporarily unavailable.');
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private isOpen(): boolean {
    if (this.failureCount >= this.threshold) {
      const now = Date.now();
      if (this.lastFailureTime && now - this.lastFailureTime < this.timeout) {
        return true;
      }
      // Timeout expired, try again
      this.reset();
    }
    return false;
  }

  private onSuccess() {
    this.failureCount = 0;
    this.lastFailureTime = null;
  }

  private onFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();
  }

  private reset() {
    this.failureCount = 0;
    this.lastFailureTime = null;
  }
}

// Usage
const geminiCircuitBreaker = new CircuitBreaker();

app.post('/api/documents/:id/analyze', async (req, res) => {
  try {
    const analysis = await geminiCircuitBreaker.execute(() =>
      analyzeDocument(documentContent)
    );

    res.json({ success: true, data: analysis });

  } catch (error: any) {
    if (error.message.includes('Circuit breaker')) {
      return res.status(503).json({
        success: false,
        error: 'Document analysis service temporarily unavailable'
      });
    }

    res.status(500).json({
      success: false,
      error: 'Failed to analyze document'
    });
  }
});
```

## Frontend Error Handling

### React Error Boundaries

```typescript
// client/src/components/ErrorBoundary.tsx
class ErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean; error: Error | null }
> {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('React error boundary caught:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-container">
          <h2>Something went wrong</h2>
          <p>Please refresh the page and try again.</p>
          {process.env.NODE_ENV === 'development' && (
            <pre>{this.state.error?.message}</pre>
          )}
        </div>
      );
    }

    return this.props.children;
  }
}
```

### API Call Error Handling

```typescript
// client/src/lib/api.ts
async function apiCall<T>(
  endpoint: string,
  options?: RequestInit
): Promise<T> {
  try {
    const response = await fetch(endpoint, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
      },
      credentials: 'include',
    });

    const data = await response.json();

    if (!response.ok) {
      throw new Error(data.error || `Request failed with status ${response.status}`);
    }

    return data.data;

  } catch (error: any) {
    console.error(`API call to ${endpoint} failed:`, error);
    throw error;
  }
}

// Usage in React component
function ContactList() {
  const { data, error, isLoading } = useQuery({
    queryKey: ['contacts'],
    queryFn: () => apiCall<Contact[]>('/api/contacts'),
  });

  if (isLoading) return <div>Loading...</div>;

  if (error) {
    return (
      <div className="error">
        <p>Failed to load contacts: {error.message}</p>
        <button onClick={() => window.location.reload()}>Retry</button>
      </div>
    );
  }

  return <div>{/* Render contacts */}</div>;
}
```

## Testing Error Handling

### Unit Tests

```typescript
// tests/error-handling.test.ts
import { describe, it, expect, vi } from 'vitest';

describe('Contact API Error Handling', () => {
  it('should return 400 for missing required fields', async () => {
    const response = await request(app)
      .post('/api/contacts')
      .send({});  // No required fields

    expect(response.status).toBe(400);
    expect(response.body.success).toBe(false);
    expect(response.body.error).toContain('required');
  });

  it('should return 404 for non-existent contact', async () => {
    const response = await request(app)
      .get('/api/contacts/invalid-id')
      .set('Cookie', validSessionCookie);

    expect(response.status).toBe(404);
    expect(response.body.success).toBe(false);
    expect(response.body.error).toBe('Contact not found');
  });

  it('should handle database errors gracefully', async () => {
    // Mock database error
    vi.spyOn(db, 'select').mockRejectedValueOnce(new Error('Connection timeout'));

    const response = await request(app)
      .get('/api/contacts')
      .set('Cookie', validSessionCookie);

    expect(response.status).toBe(500);
    expect(response.body.success).toBe(false);
    expect(response.body.error).toBe('Failed to fetch contacts');
  });
});
```

## Related Documentation

<CardGroup cols={2}>
  <Card
    title="Tenant Scoping"
    icon="sitemap"
    href="/developers/best-practices/tenant-scoping"
  >
    Multi-tenant data isolation patterns
  </Card>
  <Card
    title="Security Best Practices"
    icon="shield-check"
    href="/developers/best-practices/security"
  >
    Security guidelines and patterns
  </Card>
  <Card
    title="Testing Strategy"
    icon="vial"
    href="/developers/best-practices/testing"
  >
    Testing approaches and patterns
  </Card>
  <Card
    title="Local Development Setup"
    icon="laptop-code"
    href="/developers/local-setup"
  >
    Development environment setup
  </Card>
</CardGroup>

## Summary

**Key Error Handling Principles:**

1. **Use try-catch everywhere** - Wrap all async operations
2. **Return consistent format** - `{ success: boolean, error?: string, data?: any }`
3. **Use appropriate status codes** - 4xx for client errors, 5xx for server errors
4. **Be specific and actionable** - Clear error messages help users
5. **Don't expose sensitive info** - Be vague about authentication failures
6. **Log with context** - Include tenant ID, user ID, operation details
7. **Test error scenarios** - Unit test error cases
8. **Graceful degradation** - Continue with partial data when possible

<Warning>
**Production Error Handling**

Never expose stack traces, database errors, or sensitive information in production error responses. Use generic messages and log details server-side.
</Warning>

When in doubt, catch the error, log it with context, and return a helpful error message to the user.
